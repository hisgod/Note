# 委托


## 委托类

在委托中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另外一个对象处理

```kotlin
interface Book {
    fun page()
}

class JavaBook : Book {
    override fun page() {
        println("100")
    }
}

//A by（委托） B
class KotlinBook(private val javaBook: JavaBook) : Book by javaBook

fun main() {
    val javaBook = JavaBook()
    KotlinBook(javaBook).page()
}
```

## 委托属性

### 自定义委托

* **提供一个类，提供setValue和getValue函数，并且operator修饰**

```kotlin
fun main() {
    var name by Delegate()

    name="123"
    
    println(name)
}

class Delegate {
    var value by Delegates.notNull<String>()

    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return value
    }

    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        this.value = value
    }
}
```

### 系统委托

#### notNull

* **notNull是Kotlin提供的函数，将属性委托且不能为Null**

```kotlin
fun main() {
    var age by Delegates.notNull<Int>()

    age = 10

    println(age)
}
```

#### lazy

* **LazyThreadSafetyMode.NONE：单个线程访问**
* **LazyThreadSafetyMode.PUBLICATION：多个线程访问**

```kotlin
val name by lazy(LazyThreadSafetyMode.NONE) { 20 }

fun main() {
    println(name)
}
```

#### observable

```kotlin
class User {
    //old：旧值	new：新值
    var name: String by Delegates.observable("init") { prop, old, new ->
        println("$old -> $new")
    }
}

fun main() {
    val user = User()
    user.name = "first"
    user.name = "second"
}

//输出
init -> first
first -> second
```

## 属性存储映射

```kotlin
class User(map: Map<String, Any?>) {
    val name: String by map
    val age: Int     by map
}

fun main() {
    val user = User(mapOf(
            "name" to "John Doe",
            "age" to 25
    ))
    println(user.name) // Prints "John Doe"
    println(user.age)  // Prints 25
}
```

