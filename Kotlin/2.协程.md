# 

# 1.基础

## 1.1入门程序

* **delay：是协程挂起函数，不会造成线程阻塞，但会挂起协程，只能在协程中使用**
```
fun main(args: Array<String>) {
    GlobalScope.launch {
        //开启协程,delay是挂起函数
        delay(1000)
        print(Thread.currentThread().name)
    }
    //主线程
    println(Thread.currentThread().name)
    Thread.sleep(2000)
}
```

## 1.2桥接阻塞与非阻塞的世界

* **runBlocking：调用此函数，会阻塞线程，直到内部协程执行完毕**
```
fun main(args: Array<String>) {
    GlobalScope.launch {
        //开启协程,delay是挂起函数
        delay(1000)
        print(Thread.currentThread().name)
    }
    println(Thread.currentThread().name)
    //阻塞线程，延时2S，保持JVM存活
    runBlocking { 
        delay(2000)
    }
}
```

* **`runBlocking<Unit> { …… }`用于包装函数，泛型为函数返回值类型**
* **一般runBlocking函数不用来当做普通协程函数使用，它的主要目的是用来桥接普通阻塞代码和挂起风格的非阻塞代码**
```
fun main(args: Array<String>) = runBlocking<Unit>{
    //开启主协程
    GlobalScope.launch {
        //开启子协程
        delay(1000)
        print(Thread.currentThread().name)
    }
    println(Thread.currentThread().name)
    delay(2000)
}
```

## 等待一个作业

* **显示`joni`**
* **延迟一段时间来等待另一个协程运行并不是一个好的选择。让我们显式（以非阻塞方式）等待所启动的后台 Job 执行结束,现在，结果仍然相同，但是主协程与后台作业的持续时间没有任何关系了。好多了**

```
class Demo {
    @Test
    fun demo()= runBlocking {
        val job = GlobalScope.launch {
            println("子线程")
        }
        println("主线程")
        job.join()
    }
}
```

## 结构化的并发

* **隐式`join`**

```
class Demo {
    @Test
    fun demo()= runBlocking {
        launch {
            println("子线程")
        }
        println("主线程")
    }
}
```

## 作用域构建器

* **除了由不同的构建器提供协程作用域之外，还可以使用` coroutineScope`构建器声明自己的作用域。它会创建新的协程作用域并且在所有已启动子协程执行完毕之前不会结束。`runBlocking` 与 `coroutineScope` 的主要区别在于后者在等待所有子协程执行完毕时不会阻塞当前线程**

```
class Demo {
    @Test
    fun demo() = runBlocking {
        launch {
            println("Task from runBlocking")
        }

        coroutineScope {
            // 创建一个新的协程作用域
            launch {
                println("Task from nested launch")
            }

            println("Task from coroutine scope") // 这一行会在内嵌 launch 之前输出
        }

        println("Coroutine scope is over") // 这一行在内嵌 launch 执行完毕后才输出
    }
}

输出结果：
Task from coroutine scope
Task from runBlocking
Task from nested launch
Coroutine scope is over
```

## 提取函数重构

* **`suspend`修饰的函数，称为挂起函数，可在协程中进行调用**

```
class Demo {
    @Test
    fun demo() = runBlocking {
        launch {
            get()
        }
        println("主线程")
    }

    suspend fun get() {
        println("子线程")
    }
}
```

## 协程很轻量

* **它启动了 10 万个协程，并且在一秒钟后，每个协程都输出一个点。 现在，尝试使用线程来实现。会发生什么？**

```
import kotlinx.coroutines.*

fun main() = runBlocking {
    repeat(100_000) { // 启动大量的协程
        launch {
            delay(1000L)
            print(".")
        }
    }
}
```

# 取消&超时

## 取消协程

### 方式1

* **job.cancel()**

* **取消协程，协程就不会执行相应的逻辑**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val job = launch {
        repeat(1000) { i ->
            println("job: I'm sleeping $i ...")
        }
    }
    println("main: I'm tired of waiting!")
    job.cancel() // 取消该任务
    job.join() // 等待任务执行结束
    println("main: Now I can quit.")
}

//输出
main: I'm tired of waiting!
main: Now I can quit.
```

### 方式2

* **cancelAndJoin()**

* **取消协程，协程就不会执行相应的逻辑，并等待新协程执行完毕**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val job = launch {
        repeat(1000) { i ->
            println("job: I'm sleeping $i ...")
        }
    }
    println("main: I'm tired of waiting!")
    job.cancelAndJoin()
    println("main: Now I can quit.")
}

//输出
main: I'm tired of waiting!
main: Now I can quit.
```

### 特殊

* **当新协程调用cancelAndJoin，按道理会使新协程逻辑取消，并等待它结束，由于里面循环导致循环的逻辑还会继续执行**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i<5) { // 一个执行计算的循环，只是为了占用 CPU
            // 每秒打印消息两次
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("job: I'm sleeping ${i++} ...")
                nextPrintTime += 500L
            }
        }
    }
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // 取消一个任务并且等待它结束
    println("main: Now I can quit.")
}

//输出
main: I'm tired of waiting!
job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
job: I'm sleeping 3 ...
job: I'm sleeping 4 ...
main: Now I can quit.
```

* **显示处理：isActive是扩展函数，判断协程存活状态**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (isActive) { // 一个执行计算的循环，只是为了占用 CPU
            // 每秒打印消息两次
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("job: I'm sleeping ${i++} ...")
                nextPrintTime += 500L
            }
        }
    }
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // 取消一个任务并且等待它结束
    println("main: Now I can quit.")
}

//输出
main: I'm tired of waiting!
job: I'm sleeping 0 ...
main: Now I can quit.
```

## 超时

* **捕获异常，显然不是正确处理方式**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    withTimeout(1300L) {
        repeat(1000) { i ->
            println("I'm sleeping $i ...")
            delay(500L)
        }
    }
}

//输出
I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
```

* **正确处理方式：使用withTimeoutOrNull，通过返回 `null` 来进行超时操作，从而替代抛出一个异常**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val result = withTimeoutOrNull(1300L) {
        repeat(1000) { i ->
            println("I'm sleeping $i ...")
            delay(500L)
        }
    }
    println(result)
}

//输出
I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
null
```

# 3.通道

## 3.1协程通讯

* **使用Channel的send发送数据，receive接收数据**

```kotlin
fun main(args: Array<String>) = runBlocking {
    val channel = Channel<Int>()
    launch {
        // 这里可能是消耗大量 CPU 运算的异步逻辑，我们将仅仅做 5 次整数的平方并发送
        for (x in 1..5) channel.send(x * x)
    }
    // 这里我们打印了 5 次被接收的整数：
    repeat(5) { println(channel.receive()) }
    println("Done!")
}

//输出
1
4
9
16
25
Done!
```

* **produce实现方式**

```kotlin
fun main(args: Array<String>) = runBlocking {
    val produce = produce<Int>() {
        for (x in 1..5) send(x * x)
    }
    produce.consumeEach {
        println(it)
    }
    println("Done!")
}

//输出
1
4
9
16
25
Done!
```

