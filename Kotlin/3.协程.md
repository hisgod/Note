# 概念

线程：一个进程可以有很多线程，每条线程并行执行不同的任务

协程：协程是跑在线程上的，一个线程可以同时跑多个协程

# 基础知识

## suspend

* `suspend`函数，称为挂起函数，在协程中进行调用或挂起函数中调用
* 非`suspend`函数不可参与协程任务
* 协程中有多个挂起函数，它们的执行是顺序的，需要等待前一个挂起函数恢复，才能执行后面的挂起函数

```kotlin
class Demo {
    @Test
    fun test() {
        GlobalScope.launch {
            say()
            run()
        }

        Thread.sleep(20)

        println("结束")
    }

    suspend fun say() {
        println("说话")
    }

    suspend fun run() {
        println("跑步")
    }
}

//输出
说话
跑步
结束
```

## runBlocking

* 会阻塞线程，直到`runBlocking`内部协程执行完毕

```kotlin
class Demo {
    fun run() = runBlocking {
        repeat(10) {
            println("循环第${it}次")
        }
    }

    @Test
    fun test() {
        println("开始")
        run()
        println("结束")
    }
}

//输出
开始
循环第0次
循环第1次
循环第2次
循环第3次
循环第4次
循环第5次
循环第6次
循环第7次
循环第8次
循环第9次
结束
```

`runBlocking<Unit> { …… }`用于包装函数，泛型为函数返回值类型

```kotlin
class Demo {
    fun run() = runBlocking<String> {
        println("协程")
        return@runBlocking "执行完毕"
    }

    @Test
    fun test() {
        println("开始")
        val msg = run()
        println(msg)
        println("结束")
    }
}

//输出
开始
协程
执行完毕
结束
```



# 启动协程

## launch启动

```kotlin
class Test {
    @Test
    fun test() {
        //启动协程
        GlobalScope.launch {

        }
    }
}
```

> launch调度器

* Dispatchers.Default：不指定，即为默认
* Dispatchers.IO：IO线程
* Dispatchers.Main：主线程
* Dispatchers.Unconfined：不指定，即为当前线程

```kotlin
class Demo {
    @Test
    fun test() {
        GlobalScope.launch(Dispatchers.IO) {
        }

        Thread.sleep(1000)
    }
}

//如果不使用上面调度器，可以自定义使用下面的调度器进行开启协程
class Demo {
    @Test
    fun test() {
        //单线程
        val newSingleThreadContext = newSingleThreadContext("")
        //线程池
        val newFixedThreadPoolContext = newFixedThreadPoolContext(5, "")
        GlobalScope.launch(newSingleThreadContext) {

        }
        Thread.sleep(1000)
    }
}
```

## async启动

* `async`启动带返回值的协程

```kotlin
class Demo {
    @Test
    fun test() {
        GlobalScope.launch {
            val async1 = this.async {
                1
            }

            val async2 = this.async {
                2
            }

            println(async1.await() + async2.await())
        }

        Thread.sleep(1000)
    }
}

//输出
3
```

# 取消&超时

## 取消协程

### 方式1

* **job.cancel()**

* **取消协程，协程就不会执行相应的逻辑**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val job = launch {
        repeat(1000) { i ->
            println("job: I'm sleeping $i ...")
        }
    }
    println("main: I'm tired of waiting!")
    job.cancel() // 取消该任务
    job.join() // 等待任务执行结束
    println("main: Now I can quit.")
}

//输出
main: I'm tired of waiting!
main: Now I can quit.
```

### 方式2

* **cancelAndJoin()**

* **取消协程，协程就不会执行相应的逻辑，并等待新协程执行完毕**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val job = launch {
        repeat(1000) { i ->
            println("job: I'm sleeping $i ...")
        }
    }
    println("main: I'm tired of waiting!")
    job.cancelAndJoin()
    println("main: Now I can quit.")
}

//输出
main: I'm tired of waiting!
main: Now I can quit.
```

### 特殊

* **当新协程调用cancelAndJoin，按道理会使新协程逻辑取消，并等待它结束，由于里面循环导致循环的逻辑还会继续执行**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i<5) { // 一个执行计算的循环，只是为了占用 CPU
            // 每秒打印消息两次
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("job: I'm sleeping ${i++} ...")
                nextPrintTime += 500L
            }
        }
    }
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // 取消一个任务并且等待它结束
    println("main: Now I can quit.")
}

//输出
main: I'm tired of waiting!
job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
job: I'm sleeping 3 ...
job: I'm sleeping 4 ...
main: Now I can quit.
```

* **显示处理：isActive是扩展函数，判断协程存活状态**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (isActive) { // 一个执行计算的循环，只是为了占用 CPU
            // 每秒打印消息两次
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("job: I'm sleeping ${i++} ...")
                nextPrintTime += 500L
            }
        }
    }
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // 取消一个任务并且等待它结束
    println("main: Now I can quit.")
}

//输出
main: I'm tired of waiting!
job: I'm sleeping 0 ...
main: Now I can quit.
```

## 超时

* **捕获异常，显然不是正确处理方式**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    withTimeout(1300L) {
        repeat(1000) { i ->
            println("I'm sleeping $i ...")
            delay(500L)
        }
    }
}

//输出
I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
```

* **正确处理方式：使用withTimeoutOrNull，通过返回 `null` 来进行超时操作，从而替代抛出一个异常**

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val result = withTimeoutOrNull(1300L) {
        repeat(1000) { i ->
            println("I'm sleeping $i ...")
            delay(500L)
        }
    }
    println(result)
}

//输出
I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
null
```

# 3.通道

## 3.1协程通讯

* **使用Channel的send发送数据，receive接收数据**

```kotlin
fun main(args: Array<String>) = runBlocking {
    val channel = Channel<Int>()
    launch {
        // 这里可能是消耗大量 CPU 运算的异步逻辑，我们将仅仅做 5 次整数的平方并发送
        for (x in 1..5) channel.send(x * x)
    }
    // 这里我们打印了 5 次被接收的整数：
    repeat(5) { println(channel.receive()) }
    println("Done!")
}

//输出
1
4
9
16
25
Done!
```

* **produce实现方式**

```kotlin
fun main(args: Array<String>) = runBlocking {
    val produce = produce<Int>() {
        for (x in 1..5) send(x * x)
    }
    produce.consumeEach {
        println(it)
    }
    println("Done!")
}

//输出
1
4
9
16
25
Done!
```

